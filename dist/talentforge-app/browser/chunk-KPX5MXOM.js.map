{
  "version": 3,
  "sources": ["src/app/core/auth/auth.service.ts"],
  "sourcesContent": ["import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { Observable, BehaviorSubject, throwError } from 'rxjs';\nimport { tap, catchError, map } from 'rxjs/operators';\nimport { Router } from '@angular/router';\nimport { User, LoginRequest, RegisterRequest, AuthResponse, UserRole } from '../models/user.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n  private readonly API_URL = '/api/auth';\n  private currentUserSubject = new BehaviorSubject<User | null>(null);\n  private tokenSubject = new BehaviorSubject<string | null>(null);\n\n  public currentUser$ = this.currentUserSubject.asObservable();\n  public token$ = this.tokenSubject.asObservable();\n\n  constructor(\n    private http: HttpClient,\n    private router: Router\n  ) {\n    this.loadStoredAuth();\n  }\n\n  login(credentials: LoginRequest): Observable<AuthResponse> {\n    return this.http.post<any>(`${this.API_URL}/login`, credentials)\n      .pipe(\n        map(response => this.mapLoginResponse(response)),\n        tap(response => this.setAuthData(response)),\n        catchError(error => this.handleAuthError(error))\n      );\n  }\n\n  register(userData: RegisterRequest): Observable<AuthResponse> {\n    return this.http.post<any>(`${this.API_URL}/register`, userData)\n      .pipe(\n        map(response => this.mapLoginResponse(response)),\n        tap(response => this.setAuthData(response)),\n        catchError(error => this.handleAuthError(error))\n      );\n  }\n\n  logout(): void {\n    const token = this.getToken();\n    if (token) {\n      this.http.post(`${this.API_URL}/logout`, {}, {\n        headers: { 'Authorization': `Bearer ${token}` }\n      }).subscribe();\n    }\n    this.clearAuthData();\n    this.router.navigate(['/auth/login']);\n  }\n\n  refreshToken(): Observable<AuthResponse> {\n    return this.http.post<AuthResponse>(`${this.API_URL}/refresh`, {})\n      .pipe(\n        tap(response => this.setAuthData(response)),\n        catchError(error => {\n          this.logout();\n          return throwError(error);\n        })\n      );\n  }\n\n  getCurrentUser(): Observable<User> {\n    return this.http.get<User>(`${this.API_URL}/me`);\n  }\n\n  hasRole(role: UserRole): boolean {\n    const user = this.currentUserSubject.value;\n    return user?.role === role || false;\n  }\n\n  isAuthenticated(): boolean {\n    return !!this.tokenSubject.value && !!this.currentUserSubject.value;\n  }\n\n  getToken(): string | null {\n    return this.tokenSubject.value;\n  }\n\n  getCurrentUserValue(): User | null {\n    return this.currentUserSubject.value;\n  }\n\n  private setAuthData(response: AuthResponse): void {\n    localStorage.setItem('token', response.token);\n    localStorage.setItem('user', JSON.stringify(response.user));\n    this.tokenSubject.next(response.token);\n    this.currentUserSubject.next(response.user);\n  }\n\n  private clearAuthData(): void {\n    localStorage.removeItem('token');\n    localStorage.removeItem('user');\n    this.tokenSubject.next(null);\n    this.currentUserSubject.next(null);\n  }\n\n  private loadStoredAuth(): void {\n    const token = localStorage.getItem('token');\n    const userStr = localStorage.getItem('user');\n    \n    if (token && userStr) {\n      try {\n        const user = JSON.parse(userStr);\n        this.tokenSubject.next(token);\n        this.currentUserSubject.next(user);\n      } catch {\n        this.clearAuthData();\n      }\n    }\n  }\n\n  private mapLoginResponse(response: any): AuthResponse {\n    return {\n      user: {\n        id: response.userId,\n        email: response.email,\n        firstName: response.firstName,\n        lastName: response.lastName,\n        role: response.role,\n        isEmailVerified: true,\n        tenantId: response.tenantId,\n        tenantName: response.tenantName,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      },\n      token: response.accessToken,\n      refreshToken: response.refreshToken,\n      expiresIn: response.expiresIn\n    };\n  }\n\n  private handleAuthError(error: any): Observable<never> {\n    let errorMessage = 'An error occurred';\n    \n    if (error.status === 401) {\n      errorMessage = 'Invalid email or password';\n    } else if (error.status === 403) {\n      errorMessage = 'Please verify your email before logging in';\n    } else if (error.status === 422) {\n      errorMessage = 'Password has expired. Please reset your password';\n    } else if (error.status === 423) {\n      errorMessage = 'Account temporarily locked. Try again later';\n    } else if (error.status === 500) {\n      errorMessage = 'Service temporarily unavailable. Please try again';\n    } else if (!navigator.onLine) {\n      errorMessage = 'Connection lost. Check your internet connection';\n    }\n    \n    return throwError({ message: errorMessage, originalError: error });\n  }\n}"],
  "mappings": "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",
  "names": []
}
